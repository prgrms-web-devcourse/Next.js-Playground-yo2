# Data Fetching

## Data Fetching, Caching, and Revalidating

Next.js 데이터 fetching은 `fetch()` Web API와 React 서버 컴포넌트들을 기반으로 작동한다. 중복 요청들은 자동적으로 중복이 제거된다.

`fetch`에 객체 옵션들을 추가함으로써, 각 요청들의 **캐싱**과 **revalidate** 기능을 갖는다.

### 서버 컴포넌트 함수들

Next.js는 서버 컴포넌트들에서 데이터 fetching할 때, 필요할 수 있는 서버 함수들을 제공한다.

- `cookies()`
- `headers()`

### 데이터 캐싱

기본적으로 next.js는 반환된 값을 서버의 데이터 캐시 `fetch`에 자동으로 캐시한다. -> 다시 요청하지않고 재사용 가능

```ts
fetch("https://..."); // 캐시: 'force-cache'가 기본 옵션
```

### 데이터 revalidate(재검증)

재검증은 데이터 캐시를 제거하고 최신 데이터를 다시 가져오는 프로세스이다.

#### 시간 기반 재검증

- 일정 시간이 지나면 데이터를 자동으로 재검증

캐시된 데이터를 일정 시간 간격으로 revalidate 하려면 `next.revalidate` 옵션을 사용해 캐시의 revalidate 하기 전 유지되는 시간을 설정할 수 있다.

```ts
fetch("https://...", { next: { revalidate: 10 } });
```

#### 주문형 재검증

- 이벤트(예: form Submit 등)를 기반으로 데이터를 수동으로 재검증
- `태그` 또는 `경로 기반` 접근 방식을 사용하여 데이터 그룹을 한 번에 재검증 할 수 있다.

1. `fetch`를 사용할 때 하나 이상의 태그로 캐시 항목에 태그를 지정할 수 있는 옵션이 있다.
2. 그 다음 호출하여 `revalidateTag`와 관련된 모든 항목의 유효성을 다시 검사할 수 있다.

```ts
// collection 캐시 태그 붙이기
export default async function Page() {
####   const res = await fetch('https://...', { next: { tags: ['collection'] } })
  const data = await res.json()
  // ...
}
```

#### 동적 데이터 Fetching

모든 fetch 요청으로 최신의 데이터를 가져오려면 `cache: 'no-store'` 옵션을 사용한다.

```ts
fetch("https://...", { cache: "no-store" });
```

> **오류 처리 및 재검증**

- 데이터 재검증을 시도 중에 오류가 발생하면 `마지막으로 성공적으로 생성된 데이터가 캐시에서 계속 제공`된다. 다음 요청에서 데이터를 재검증 시도한다.

#### 다중 fetch 요청

경로 세그먼트에 여러 요청이 있는 경우 fetch 세그먼트 구성 옵션을 사용해 세그먼트에 있는 모든 데이터 요청의 캐싱 동작을 구성할 수 있다.

예를 들어 `const dynamic = 'force-dynamic`을 사용하면 요청 시 모든 데이터를 가져오고 세그먼트가 동적으로 렌더링 된다.

```ts
export const dynamic = "force-dynamic";
```

> 광범위한 세그먼트 구성 옵션 목록이 있어 경로 세그먼트의 정적 및 동적 동작을 세밀하게 제어할 수 있습니다.

### 읽어보기

데이터 캐시 여부는 경로 세그먼트의 정적, 동적 렌더링 여부에 따라 달라진다. 세그먼트가 정적인 경우 요청 출력은 경로 세그먼트의 일부로 캐시되고 재검증된다. 동적인 경우 요청 출력은 캐시되지 않으며 세그먼트가 렌더링될 때 모든 요청에서 다시 가져온다.

## Data Fetching Patterns

### 서버에서 데이터 가져오기

서버에서 데이터를 가져온다면 아래의 기능을 수행할 수 있기 때문에 서버에서 데이트를 가져오는 것이 좋다.

- 백엔드 데이터 리소스(예: 데이터베이스)에 직접 액세스 할 수 있다.
- 액세스 토큰, API 키 등 민감한 정보가 클라이언트에 노출되는 것을 방지한다.
- 동일한 환경에서 데이터를 가져오고 렌더링하기 때문에 클라이언트 서버 간의 통신과 메인 스레드의 작업이 모두 줄어든다.
- 클라이언트에서 여러 개별 요청을 수행하는 대신 단일 왕복으로 여러 데이터 가져오기를 수행한다.
- 클라이언트 - 서버 간 폭포수를 줄인다.
- 데이터 가져오기가 데이터 소스에 가까운 곳에서 발생하여 대기 시간이 줄어들고 성능이 향상될 수 있다.

### 필요한 곳에서 데이터 가져오기

트리의 여러 구성 요소에서 동일한 데이터(예: 현재 사용자)를 사용하는 경우 전역적으로 데이터를 가져오거나 구성요소 간 전달할 필요가 없다.

> 동일한 데이터를 여러 번 요청하는 경우 성능에 걱정할 필요 없이 데이터가 필요한 구성 요소에서 `fetch`를 사용할 수 있습니다.

### 스트리밍

`스트리밍`과 `Suspense`는 UI의 렌더링된 단위를 클라이언트에 점진적으로 렌더링하고 스트리밍할 수 있게 해주는 React 기능이다.

> 서버 구성 요소 및 중첩 레이아웃을 사용하면 데이터가 필요하지 않은 페이지 부분을 즉시 렌더링하고 `데이터 로드 상태`를 표시할 수 있다. 즉, 사용자는 상호 작용을 하기 전 전체 페이지가 로드될 때까지 기다릴 필요가 없다.
