## 서버 컴포넌트

서버 및 클라이언트 컴포넌트를 사용하면 개발자는 클라이언트 측 앱의 풍부한 상호 작용과 기존 서버 렌더링의 향상된 성능을 결합하여 서버와 클라이언트를 아우르는 애플리케이션을 구축할 수 있다.

SPA처럼 전체를 클라이언트에서 렌더링하는 대신 컴포넌트 목적에 따라 렌더링 할 위치를 선택할 수 있는 유연성을 제공한다.

> 페이지를 더 작은 컴포넌트로 분할하면 대부분의 컴포넌트가 인터렉션이 없는 컴포넌트이며 서버에서 `서버 컴포넌트로 렌더링할 수 있음`을 알 수 있습니다.

### 왜 서버 컴포넌트일까?

클라이언트 컴포넌트가 아닌 서버 컴포넌트를 사용하면 어떤 장점이 있을까?

**서버 인프라를 잘 활용할 수 있다.**

예를 들어, 데이터 불러오기를 데이터베이스에 더 가까운 서버로 옮기고, 이전에는 클라이언트 자바스크립트 번들 크기에 영향을 미쳤던 대규모 종속성을 서버에 유지하여 성능을 개선할 수 있다.

**초기 페이지 로딩이 빨라지고 자바스크립트 번들 크기가 줄어든다.**

기본 클라이언트 측 실행시간은 <U>`캐시가 가능하고`</U> 크기를 예측할 수 있으며 애플리케이션이 커져도 증가하지 않는다. 추가적인 자바스크립트는 클라이언트 컴포넌트를 통해 사용자와 상호 작용이 사용될 때만 추가된다.

> Next.js로 경로가 로드되면 초기 HTML이 서버에서 렌더링 됩니다. 그런 다음, 이 HTML은 브라우저에서 점진적으로 향상되어 클라이언트가 Next.js 및 React 클라이언트 측 실행시간을 비동기적으로 로드하여 애플리케이션을 넘겨받아 상호 작용을 추가할 수 있습니다.

> 서버 컴포넌트로 쉽게 전환할 수 있도록 App Router 내의 모든 컴포넌트는 기본적으로 서버 컴포넌트로 전환됩니다. `'use client'` 지시문을 사용하여 선택적으로 클라이언트 컴포넌트를 사용할 수도 있습니다.

1. 서버 컴포넌트 모듈 그래프의 컴포넌트는 서버에서만 렌더링 되도록 보장된다.
2. 클라이언트 컴포넌트 모듈 그래프의 컴포넌트는 주로 클라이언트에서 렌더링 되지만 Next.js를 사용하면 서버에서 미리 렌더링한 후 클라이언트에서 하이드레이션할 수 있다.
3. "use client" 지시문은 가져오기 전에 파일 상단에 정의해야 한다.
4. "use client"를 모든 파일에 정의할 필요는 없다. 클라이언트 모듈 경계는 "진입점"에서 한 번만 정의하면 되며, 이 경계로 가져온 모든 모듈은 클라이언트 컴포넌트로 간주한다.

### 클라이언트 컴포넌트

클라이언트 컴포넌트를 사용하면 애플리케이션에 클라이언트 측 상호 작용을 추가할 수 있다. Next.js에서는 서버에서 미리 렌더링되고 클라이언트에서 `하이드레이션`된다.

**🎶 하이드레이션이란?**

> 웹 개발에서 수화 또는 재수화는 클라이언트 측 JavaScript가 정적 호스팅 또는 서버 측 렌더링을 통해 전달된 정적 HTML 웹 페이지를 HTML 요소에 이벤트 핸들러를 연결하여 동적 웹 페이지로 변환하는 기술입니다.

### 패턴들

**클라이언트 컴포넌트를 컴포넌트 트리의 끝으로 이동하기**

전체 레이아웃을 클라이언트 컴포넌트로 만드는 대신 인터랙티브 로직을 클라이언트 컴포넌트(예: <SearchBar />)로 이동하고 레이아웃은 서버 컴포넌트로 유지한다. 즉, 레이아웃의 모든 컴포넌트 자바스크립트를 클라이언트에 전송할 필요가 없다.

> **알아두면 유용한 정보** : Next.js에서는 초기 페이지 로딩 시 위 단계의 서버 컴포넌트와 클라이언트 컴포넌트의 렌더링 결과가 모두 서버에서 HTML로 미리 렌더링되어 초기 페이지 로딩 속도가 빨라집니다.

**클라이언트 컴포넌트 안에 서버 컴포넌트 중첩**

- 서버 컴포넌트를 클라이언트 컴포넌트로 가져오기 (지원 X)

```js
"use client";

// 이 패턴은 **작동하지** 않습니다!
// 서버 컴포넌트를 클라이언트 컴포넌트로 임포트할 수 없습니다.
import ExampleServerComponent from "./example-server-component";

export default function ExampleClientComponent({ children }: { children: React.ReactNode }) {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      <ExampleServerComponent />
    </>
  );
}
```

- 서버 컴포넌트를 클라이언트 컴포넌트에 prop으로 전달하기 (권장 패턴)
  - React props를 사용하여 서버 컴포넌트에 `구멍`을 표시할 수 있다.

서버 컴포넌트는 서버에서 렌더링되고 클라이언트 컴포넌트가 클라이언트에서 렌더링될 때 "구멍"은 서버 컴포넌트의 렌더링된 결과로 채워진다.

> 일반적인 패턴은 React children prop을 사용하여 "구멍"을 만드는 것입니다. 일반 children prop을 허용하도록`<ExampleClientComponent>`를 리팩터링하고`<ExampleClientComponent>`의 임포트와 명시적 중첩을 부모 컴포넌트로 옮길 수 있습니다.

```ts
"use client";

import { useState } from "react";

export default function ExampleClientComponent({ children }: { children: React.ReactNode }) {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>

      {children}
    </>
  );
}
```

```ts
// 이 패턴은 효과가 있습니다.
// 서버 컴포넌트를 자식이나 프로퍼티로 전달할 수 있습니다.
// 클라이언트 컴포넌트로 전달할 수 있습니다.
import ExampleClientComponent from "./example-client-component";
import ExampleServerComponent from "./example-server-component";

// Next.js의 페이지는 기본적으로 서버 컴포넌트입니다.
export default function Page() {
  return (
    <ExampleClientComponent>
      <ExampleServerComponent />
    </ExampleClientComponent>
  );
}
```

이제 `<ExampleClientComponent>`는 children이 무엇인지에 대한 지식이 없다. 이 컴포넌트 관점에서는 children이 결국 서버 컴포넌트의 결과에 의해 채워질 것이라는 사실조차 알지 못한다.

ExampleClientComponent의 유일한 책임은 **`children이 최종적으로 배치될 위치를 결정하는 것`** 이다. 이 접근 방식을 사용하면 렌더링이 분리되어 독립적으로 렌더링될 수 있으며, 클라이언트 컴포넌트보다 먼저 서버에서 렌더링되는 서버 컴포넌트에 맞춰 조정된다.

**서버에서 클라이언트 컴포넌트로 props 전달하기(직렬화)**

서버에서 클라이언트 컴포넌트로 전달되는 소품은 직렬화 가능이어야 한다. 즉, 함수, 날짜 등과 같은 값은 클라이언트 컴포넌트에 직접 전달할 수 없다.

**데이터 가져오기**

클라이언트 컴포넌트에서 데이터를 가져올 수 있지만 클라이언트에서 데이터를 가져와야 하는 특별한 이유가 없는 한 서버 컴포넌트에서 데이터를 가져오는 것을 권장한다. 데이터 가져오기를 서버로 옮기면 성능과 사용자 환경이 개선된다.

## Context

Next.js 13에서는 `context`가 클라이언트 컴포넌트 내에서는 완벽하게 지원되지만 `서버 컴포넌트 내에서 직접 생성하거나 사용할 수 없다.`

> 서버 컴포넌트에는 (인터랙티브하지 않기 때문에) React state가 없고, context는 주로 일부 React state가 업데이트된 후 트리 깊숙한 곳에 있는 인터랙티브 컴포넌트를 다시 렌더링하는 데 사용되기 때문입니다.

이 문제를 해결하려면 context를 생성하고 클라이언트 컴포넌트 내에서 해당 프로바이더를 렌더링해야 한다.

```ts
"use client";

import { createContext } from "react";

export const ThemeContext = createContext({});

export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value='dark'>{children}</ThemeContext.Provider>;
}
```

서버 컴포넌트가 클라이언트 컴포넌트로 표시되었으므로 공급자를 직접 렌더링할 수 있다.

```ts
import ThemeProvider from "./theme-provider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  );
}
```

공급자가 루트에서 렌더링되면 앱의 다른 모든 클라이언트 컴포넌트가 이 context를 사용할 수 있다.

## 서버 컴포넌트 간 가져오기 요청 공유

데이터를 가져올 때 page 또는 layout과 일부 하위 컴포넌트 간에 fetch 결과를 공유하고 싶을 수 있다. 이는 컴포넌트 간에 불필요한 연결이 발생하여 컴포넌트 간에 props가 앞뒤로 전달될 수 있다.

대신 데이터를 소비하는 컴포넌트와 함께 데이터 가져오기를 함께 배치하는 것이 좋다. 서버 컴포넌트에서 fetch 요청이 자동으로 중복 제거되므로 각 경로 세그먼트는 중복 요청에 대한 걱정 없이 필요한 데이터만 정확하게 요청할 수 있다. Next.js는 fetch 캐시에서 동일한 값을 읽는다.

## 페이지와 레이아웃

### 페이지

페이지는 `라우트의 고유한 UI`이다. **중첩 폴더**를 사용하여 라우트를 정의하고 page 파일을 사용해 공개적으로 라우트에 접근할 수 있도록 한다.

### 레이아웃

레이아웃은 `여러 페이지 간에 공유되는 UI`이다. 탐색할 때 레이아웃은 state를 보존하고 상호작용하는 state를 유지하며 재 렌더링을 하지 않는다. 레이아웃은 `중첩`될 수 있다.

> **참고** :

- 가장 위에 있는 레이아웃을 루트 레이아웃이라고 한다. 이 필수 레이아웃은 애플리케이션의 모든 페이지에서 공유되고 html 과 body 태그가 반드시 포함되어야 한다.
- 모든 세그먼트 라우트는 선택적으로 자체 레이아웃을 정의할 수 있다. 이러한 레이아웃은 해당 세그먼트 모든 페이지에서 공유된다.
  라우트의 레이아웃은 기본적으로 중첩되므로 각 부모 레이아웃은 React children 프로퍼티를 사용해 하위의 자식 레이아웃을 감싸준다.
- 라우트 그룹을 사용하여 공유 레이아웃 안팎에서 특정한 라우트 세그먼트를 선택할 수 있다.
- 부모 레이아웃과 자식 레이아웃 간에 데이터를 전달할 수 없다. 하지만 라우트에서 동일한 데이터를 한 번 이상 가져올 수 있으며, React는 성능에 영향을 주지 않고 요청을 자동으로 중복을 제거한다.
- 레이아웃은 현재 라우트의 세그먼트에 접근할 수 없습니다. 라우트 세그먼트에 접근하려면, 클라이언트 컴포넌트의`useSelectedLayoutSegment` 혹은 `useSelectedLayoutSegments`을 사용할 수 있다.
- layout.js 와 page.js 파일은 같은 폴더에 정의할 수 있고 레이아웃이 페이지를 감싸게 된다.
- 루트 레이아웃은 기본적으로 서버 컴포넌트이며 `클라이언트 컴포넌트로 설정할 수 없다.`

### 템플릿(Templates)

> 템플릿은 각 하위 레이아웃이나 페이지를 래핑한다는 점에서 레이아웃과 유사하지만 경로 전반에 걸쳐 지속되고 상태를 유지하는 레이아웃과 달리 템플릿은 **`탐색 시 각 하위 항목에 대해 새 인스턴스를 만든다.`** 이는 사용자가 템플릿을 공유하는 경로 사이를 탐색할 때 구성 요소의 새 인스턴스가 마운트되고 DOM 요소가 다시 생성되며 상태가 유지되지 않고 효과가 다시 동기화된다는 것을 의미한다.

#### 언제 템플릿을 사용할 수 있을까?

- CSS 또는 애니메이션 라이브러리를 사용하여 애니메이션을 입력 or 종료 시
- `useEffect`(예: 페이지 조회 수 로깅) 및 `useState`(예: 페이지 별 피드백 폼)에 의존하는 기능들.
- 프레임워크의 기본적인 동작을 변경할 때 : 예를 들어 레이아웃 내부의 서스펜스 라우트는 레이아웃을 처음 로드할 때만 fallback을 표시하고 페이지를 전환할 때는 표시하지 않는다. 템플릿의 경우 각 탐색에 fallback이 표시된다.

> **권장사항** : 템플릿을 사용해야 할 특별한 이유가 없는 한 레이아웃을 사용하는 것이 좋다.

## Link와 Navigation

Next.js 라우터는 `서버 중심 라우팅`과 `클라이언트 사이드 내비게이션`을 사용한다. 즉, 내비게이션은 클라이언트 측 상태를 유지하고 비용이 많이 드는 리렌더링을 피하고 중단 가능하며 경쟁 상태를 일으키지 않는다.

라우트 사이를 이동하는 방법에는 두 가지가 있다.

- `<Link>` 컴포넌트
- useRouter() Hook

> **권장** : `useRouter`를 사용하라는 특별한 요구사항이 없는 한, 라우트 간에 이동할 때 `<Link>` 컴포넌트를 사용하는 것이 좋다.

### 라우팅 및 탐색 작동 방식

- 서버에서 애플리케이션 코드는 경로 세그먼트별로 자동으로 코드 분할 된다.
- 클라이언트에서 `Next.js`는 경로 세그먼트를 미리 가져 오고 캐시한다.

즉, 사용자가 새 경로로 이동할 때 브라우저는 페이지를 다시 로드하지 않고 변경된 경로 세그먼트만 다시 렌더링하여 탐색 경험과 성능을 향상시킨다.

## Route Group

`app` 디렉토리에서 중첩된 폴더는 일반적으로 URL 경로에 매핑된다. 이를 원치 않는다면, 원하는 폴더를 `라우트 그룹`으로 지정해 폴더를 라우트의 URL 경로에 포함되는 것을 막을 수 있다.

### 유용한 경우

- URL 경로에 영향을 주지 않고 라우트를 그룹화 하고 싶은 경우
- 동일한 세그먼트 수준에서 중첩된 레이아웃 활성화
  - 여러 루트 레이아웃을 포함하여 동일한 세그먼트에 여러 중첩 레이아웃 만들기
  - 공통 구간의 경로 하위 집합에 레이아웃 추가

### 컨벤션

> 라우트 그룹은 폴더 이름을 괄호로 감싸서 만든다. `(folderName)`

> **참고 :**

- 라우트 그룹의 이름은 그룹화를 통한 정리를 위한 것일뿐, 다른 특별한 의미는 없다. 라우트 그룹 이름이 URL 경로에 영향을 주지 않는다.
- 다른 라우트 그룹을 포함하는 라우트는 다른 라우트와 같은 URL 경로로 귀결되면 안된다. 예를 들어, 라우트 그룹은 URL 구조에 영향을 주지 않으므로 `(marketing)/about/page.js` 파일과`(shop)/about/page.js` 파일 모두 `/about 경로`에 귀결되어 에러를 발생시킨다.
- 최상위 폴더에 layout.js 파일 없이 루트 레이아웃을 여러 개 사용하는 경우, app/(marketing)/page.js 처럼 page.js 파일이 라우트 그룹 중 하나에 정의되어야 한다.
- 여러 루트 레이아웃을 거쳐 탐색하는 경우, 클라이언트 측 탐색과 달리 전체 페이지 로드(full page load)가 된다. 예를 들어, `app/(shop)/layout.js` 파일을 사용하는 `/cart` 에서부터 `app/(marketing)/layout.js` 파일을 사용하는 `/blog` 으로 이동하면 전체 페이지 로딩이 발생한다. 이것은 다중 루트 레이아웃이 있을 때만 적용된다.

## 동적 라우트

정확한 세그먼트 이름을 미리 알 수 없어 동적 데이터로 라우트를 생성하려는 경우, 요청 시 채워지거나 빌드 시 미리 렌더링 되는 동적 세그먼트를 사용할 수 있다.

동적 세그먼트는 `layout`, `page`, `route` 및 `생성 메타데이터 함수`에 **`params`** 프로퍼티로 전달된다.

```tsx filename="app/blog/[slug]/page.tsx" switcher
export default function Page({ params }: { params: { slug: string } }) {
  return <div>My Post: {params.slug}</div>;
}
```

| Route                     | Example URL | `params`        |
| ------------------------- | ----------- | --------------- |
| `app/blog/[slug]/page.js` | `/blog/a`   | `{ slug: 'a' }` |
| `app/blog/[slug]/page.js` | `/blog/b`   | `{ slug: 'b' }` |
| `app/blog/[slug]/page.js` | `/blog/c`   | `{ slug: 'c' }` |
